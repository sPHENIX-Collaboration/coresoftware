#include "SvtxEvaluator.h"

#include "SvtxEvalStack.h"

#include <phool/PHCompositeNode.h>
#include <fun4all/Fun4AllReturnCodes.h>
#include <phool/getClass.h>
#include <phool/PHTimeServer.h>
#include <phool/PHTimer.h>

#include <g4hough/SvtxVertexMap.h>
#include <g4hough/SvtxVertex.h>
#include <g4hough/SvtxTrackMap.h>
#include <g4hough/SvtxTrack.h>
#include <g4hough/SvtxClusterMap.h>
#include <g4hough/SvtxCluster.h>
#include <g4hough/SvtxHitMap.h>
#include <g4hough/SvtxHit.h>

#include <g4main/PHG4Hit.h>
#include <g4main/PHG4Particle.h>
#include <g4main/PHG4VtxPoint.h>
#include <g4main/PHG4TruthInfoContainer.h>

#include <g4detectors/PHG4Cell.h>
#include <g4detectors/PHG4CylinderCellGeom.h>
#include <g4detectors/PHG4CylinderCellGeomContainer.h>

#include <TFile.h>
#include <TNtuple.h>
#include <TVector3.h>

#include <iostream>
#include <set>
#include <cmath>
#include <cassert>
#include <algorithm>

using namespace std;

SvtxEvaluator::SvtxEvaluator(const string &name, const string &filename, const string &trackmapname,
		unsigned int nlayers_maps,
		unsigned int nlayers_intt,
		unsigned int nlayers_tpc) :
  SubsysReco("SvtxEvaluator"),
  _ievent(0),
  _svtxevalstack(nullptr),
  _strict(false),
  _errors(0),
  _do_vertex_eval(true),
  _do_gpoint_eval(true),
  _do_g4hit_eval(true),
  _do_hit_eval(true),
  _do_cluster_eval(true),
  _do_gtrack_eval(true),
  _do_track_eval(true),
  _do_track_match(true),
  _do_eval_light(true),
  _scan_for_embedded(false),
  _nlayers_maps(nlayers_maps),
  _nlayers_intt(nlayers_intt),
  _nlayers_tpc(nlayers_tpc),
  _ntp_vertex(nullptr),
  _ntp_gpoint(nullptr),
  _ntp_g4hit(nullptr),
  _ntp_hit(nullptr),
  _ntp_cluster(nullptr),
  _ntp_gtrack(nullptr),
  _ntp_track(nullptr),
  _filename(filename),
  _trackmapname(trackmapname),
  _tfile(nullptr),
  _timer(nullptr)
{
  verbosity = 0;
}

int SvtxEvaluator::Init(PHCompositeNode *topNode) {
  
  _ievent = 0;

  _tfile = new TFile(_filename.c_str(), "RECREATE");

  if (_do_vertex_eval) _ntp_vertex = new TNtuple("ntp_vertex","vertex => max truth",
						 "event:vx:vy:vz:ntracks:"
						 "gvx:gvy:gvz:gvt:gntracks:"
						 "nfromtruth");

  if (_do_gpoint_eval) _ntp_gpoint = new TNtuple("ntp_gpoint","g4point => best vertex",
						 "event:gvx:gvy:gvz:gvt:gntracks:gembed:"
						 "vx:vy:vz:ntracks:"
						 "nfromtruth");
  
  if (_do_g4hit_eval) _ntp_g4hit = new TNtuple("ntp_g4hit","g4hit => best svtxcluster",
					       "event:g4hitID:gx:gy:gz:gt:gedep:gphi"
					       "glayer:gtrackID:gflavor:"
					       "gpx:gpy:gpz:"
					       "gvx:gvy:gvz:"
					       "gfpx:gfpy:gfpz:gfx:gfy:gfz:"
					       "gembed:gprimary:nclusters:"
					       "clusID:x:y:z:e:adc:layer:size:"
					       "phisize:zsize:efromtruth");

  if (_do_hit_eval) _ntp_hit = new TNtuple("ntp_hit","svtxhit => max truth",
					   "event:hitID:e:adc:layer:"
					   "cellID:ecell:phibin:zbin:phi:z:"
					   "g4hitID:gedep:gx:gy:gz:gt:"
					   "gtrackID:gflavor:"
					   "gpx:gpy:gpz:gvx:gvy:gvz:"
					   "gfpx:gfpy:gfpz:gfx:gfy:gfz:"
					   "gembed:gprimary:efromtruth");

  if (_do_cluster_eval) _ntp_cluster = new TNtuple("ntp_cluster","svtxcluster => max truth",
						   "event:hitID:x:y:z:r:phi:eta:ex:ey:ez:ephi:"
						   "e:adc:layer:size:phisize:"
						   "zsize:trackID:g4hitID:gx:"
						   "gy:gz:gr:gphi:geta:gt:gtrackID:gflavor:"
						   "gpx:gpy:gpz:gvx:gvy:gvz:"
						   "gfpx:gfpy:gfpz:gfx:gfy:gfz:"
						   "gembed:gprimary:efromtruth:nparticles");

  if (_do_gtrack_eval) _ntp_gtrack  = new TNtuple("ntp_gtrack","g4particle => best svtxtrack",
						  "event:gtrackID:gflavor:gnhits:gnmaps:gnintt:gntpc:gnlmaps:gnlintt:gnltpc:"
						  "gpx:gpy:gpz:gpt:geta:gphi:"
						  "gvx:gvy:gvz:gvt:"
						  "gfpx:gfpy:gfpz:gfx:gfy:gfz:"
						  "gembed:gprimary:"
						  "trackID:px:py:pz:pt:eta:phi:"
						  "charge:quality:chisq:ndf:nhits:layers:nmaps:nintt:ntpc:nlmaps:nlintt:nltpc:"
						  "dca2d:dca2dsigma:dca3dxy:dca3dxysigma:dca3dz:dca3dzsigma:pcax:pcay:pcaz:nfromtruth:nwrong:ntrumaps:ntruintt:ntrutpc:layersfromtruth");
  
  if (_do_track_eval) _ntp_track = new TNtuple("ntp_track","svtxtrack => max truth",
					       "event:trackID:px:py:pz:pt:eta:phi:charge:"
					       "quality:chisq:ndf:nhits:nmaps:nintt:ntpc:nlmaps:nlintt:nltpc:layers:"
					       "dca2d:dca2dsigma:dca3dxy:dca3dxysigma:dca3dz:dca3dzsigma:pcax:pcay:pcaz:"
					       "presdphi:presdeta:prese3x3:prese:"   
					       "cemcdphi:cemcdeta:cemce3x3:cemce:"
					       "hcalindphi:hcalindeta:hcaline3x3:hcaline:"
					       "hcaloutdphi:hcaloutdeta:hcaloute3x3:hcaloute:"
					       "gtrackID:gflavor:gnhits:gnmaps:gnintt:gntpc:gnlmaps:gnlintt:gnltpc:"
					       "gpx:gpy:gpz:gpt:geta:gphi:"
					       "gvx:gvy:gvz:gvt:"
					       "gfpx:gfpy:gfpz:gfx:gfy:gfz:"
					       "gembed:gprimary:nfromtruth:nwrong:ntrumaps:ntruintt:ntrutpc:layersfromtruth");

  _timer = new PHTimer("_eval_timer");
  _timer->stop();

  return Fun4AllReturnCodes::EVENT_OK;
}

int SvtxEvaluator::InitRun(PHCompositeNode *topNode) {
  return Fun4AllReturnCodes::EVENT_OK;
}
  
int SvtxEvaluator::process_event(PHCompositeNode *topNode) {
  
  if ((verbosity > 0)&&(_ievent%100==0)) {
    cout << "SvtxEvaluator::process_event - Event = " << _ievent << endl;
  }

  if (!_svtxevalstack) {
    _svtxevalstack = new SvtxEvalStack(topNode);
    _svtxevalstack->set_strict(_strict);
    _svtxevalstack->set_verbosity(verbosity+1);
  } else {
    _svtxevalstack->next_event(topNode);
  }
  
  //-----------------------------------
  // print what is coming into the code
  //-----------------------------------
  
  printInputInfo(topNode);
  
  //---------------------------
  // fill the Evaluator NTuples
  //---------------------------

  fillOutputNtuples(topNode);
  
  //--------------------------------------------------
  // Print out the ancestry information for this event
  //--------------------------------------------------
  
  printOutputInfo(topNode);
  
  ++_ievent;
  return Fun4AllReturnCodes::EVENT_OK;
}

int SvtxEvaluator::End(PHCompositeNode *topNode) {

  _tfile->cd();

  if (_ntp_vertex)  _ntp_vertex->Write();
  if (_ntp_gpoint)  _ntp_gpoint->Write();
  if (_ntp_g4hit)   _ntp_g4hit->Write();
  if (_ntp_hit)     _ntp_hit->Write();
  if (_ntp_cluster) _ntp_cluster->Write();
  if (_ntp_gtrack)  _ntp_gtrack->Write();
  if (_ntp_track)   _ntp_track->Write();

  _tfile->Close();

  delete _tfile;

  if (verbosity >  0) {
    cout << "========================= SvtxEvaluator::End() ============================" << endl;
    cout << " " << _ievent << " events of output written to: " << _filename << endl;
    cout << "===========================================================================" << endl;
  }

  _errors += _svtxevalstack->get_errors();
  
  if (verbosity > -1) {
    if ((_errors > 0)||(verbosity > 0)) {
      cout << "SvtxEvaluator::End() - Error Count: " << _errors << endl;
    }
  }
  
  delete _svtxevalstack;
  
  return Fun4AllReturnCodes::EVENT_OK;
}

void SvtxEvaluator::printInputInfo(PHCompositeNode *topNode) {
  
  if (verbosity > 1) cout << "SvtxEvaluator::printInputInfo() entered" << endl;

  if (verbosity > 3) {
    
    // event information
    cout << endl;
    cout << PHWHERE << "   INPUT FOR EVENT " << _ievent << endl;

    cout << endl;
    cout << "---PHG4HITS-------------" << endl;
    _svtxevalstack->get_truth_eval()->set_strict(_strict);
    std::set<PHG4Hit*> g4hits = _svtxevalstack->get_truth_eval()->all_truth_hits();
    unsigned int ig4hit = 0;
    for(std::set<PHG4Hit*>::iterator iter = g4hits.begin();
	iter != g4hits.end();
	++iter) {
      PHG4Hit *g4hit = *iter;
      cout << ig4hit << " of " << g4hits.size();
      cout << ": PHG4Hit: " << endl;
      g4hit->identify();
      ++ig4hit;
    }

    cout << "---SVTXCLUSTERS-------------" << endl;
    SvtxClusterMap* clustermap = findNode::getClass<SvtxClusterMap>(topNode,"SvtxClusterMap");
    if (clustermap) {
      unsigned int icluster = 0;
      for (SvtxClusterMap::Iter iter = clustermap->begin();
	   iter != clustermap->end();
	   ++iter) {
	SvtxCluster* cluster = iter->second;
	cout << icluster << " of " << clustermap->size();	  
	cout << ": SvtxCluster: " << endl;
	cluster->identify();
	++icluster;
      }
    }

    cout << "---SVXTRACKS-------------" << endl;
    SvtxTrackMap* trackmap = findNode::getClass<SvtxTrackMap>(topNode,_trackmapname.c_str());
    if (trackmap) {
      unsigned int itrack = 0;
      for (SvtxTrackMap::Iter iter = trackmap->begin();
	   iter != trackmap->end();
	   ++iter) {
	cout << itrack << " of " << trackmap->size();
	SvtxTrack *track = iter->second;
	cout << " : SvtxTrack:" << endl;
	track->identify();
	cout << endl;
      }
    }
    
    cout << "---SVXVERTEXES-------------" << endl;
    SvtxVertexMap* vertexmap = findNode::getClass<SvtxVertexMap>(topNode,"SvtxVertexMap");
    if (vertexmap) {
      unsigned int ivertex = 0;
      for (SvtxVertexMap::Iter iter = vertexmap->begin();
	   iter != vertexmap->end();
	   ++iter) {
	cout << ivertex << " of " << vertexmap->size();
	SvtxVertex *vertex = iter->second;
	cout << " : SvtxVertex:" << endl;
	vertex->identify();
	cout << endl;
      }
    }
  }

  return;
}

void SvtxEvaluator::printOutputInfo(PHCompositeNode *topNode) {
  
  if (verbosity > 1) cout << "SvtxEvaluator::printOutputInfo() entered" << endl;

  //==========================================
  // print out some useful stuff for debugging
  //==========================================

  if (verbosity > 0) {
    
    SvtxTrackEval*     trackeval = _svtxevalstack->get_track_eval();
    SvtxClusterEval* clustereval = _svtxevalstack->get_cluster_eval();
    SvtxTruthEval*     trutheval = _svtxevalstack->get_truth_eval();
  
    // event information
    cout << endl;
    cout << PHWHERE << "   NEW OUTPUT FOR EVENT " << _ievent << endl;
    cout << endl;

    PHG4TruthInfoContainer* truthinfo = findNode::getClass<PHG4TruthInfoContainer>(topNode,"G4TruthInfo");
    
    PHG4VtxPoint *gvertex = truthinfo->GetPrimaryVtx( truthinfo->GetPrimaryVertexIndex() );
    float gvx = gvertex->get_x();
    float gvy = gvertex->get_y();
    float gvz = gvertex->get_z();

    float vx = NAN;
    float vy = NAN;
    float vz = NAN;

    SvtxVertexMap* vertexmap = findNode::getClass<SvtxVertexMap>(topNode,"SvtxVertexMap");    
    if (vertexmap) {
      if (!vertexmap->empty()) {
	SvtxVertex* vertex = (vertexmap->begin()->second);
	
	vx = vertex->get_x();
	vy = vertex->get_y();
	vz = vertex->get_z();
      }
    }

    cout << "===Vertex Reconstruction=======================" << endl;
    cout << "vtrue = (" << gvx << "," << gvy << "," << gvz << ") => vreco = (" << vx << "," << vy << "," << vz << ")" << endl;
    cout << endl;

    cout << "===Tracking Summary============================" << endl;
    unsigned int ng4hits[100] = {0};
    std::set<PHG4Hit*> g4hits = trutheval->all_truth_hits();
    for (std::set<PHG4Hit*>::iterator iter = g4hits.begin();
	 iter != g4hits.end();
	 ++iter) {
      PHG4Hit *g4hit = *iter;
      ++ng4hits[g4hit->get_layer()];
    }

    SvtxHitMap* hitmap = findNode::getClass<SvtxHitMap>(topNode,"SvtxHitMap");
    unsigned int nhits[100] = {0};
    if (hitmap) {
      for (SvtxHitMap::Iter iter = hitmap->begin();
	   iter != hitmap->end();
	   ++iter) {
	SvtxHit* hit = iter->second;
	++nhits[hit->get_layer()];
      }
    }
    
    SvtxClusterMap* clustermap = findNode::getClass<SvtxClusterMap>(topNode,"SvtxClusterMap");
    unsigned int nclusters[100] = {0};
    if (clustermap) {
      for (SvtxClusterMap::Iter iter = clustermap->begin();
	   iter != clustermap->end();
	   ++iter) {
	SvtxCluster* cluster = iter->second;
	++nclusters[cluster->get_layer()];
      }
    }
    for (unsigned int ilayer = 0; ilayer < _nlayers_maps + _nlayers_intt+ _nlayers_tpc; ++ilayer) {
      cout << "layer " << ilayer << ": nG4hits = " << ng4hits[ilayer]
	   << " => nHits = " << nhits[ilayer]
	   << " => nClusters = " << nclusters[ilayer] << endl;
    }

    SvtxTrackMap* trackmap = findNode::getClass<SvtxTrackMap>(topNode,_trackmapname.c_str());
    
    cout << "nGtracks = " << std::distance(truthinfo->GetPrimaryParticleRange().first,
					  truthinfo->GetPrimaryParticleRange().second);
    cout << " => nTracks = ";
    if (trackmap) cout << trackmap->size() << endl;
    else cout << 0 << endl;

    // cluster wise information
    if (verbosity > 1) {
 
      for(std::set<PHG4Hit*>::iterator iter = g4hits.begin();
	  iter != g4hits.end();
	  ++iter) {
	PHG4Hit *g4hit = *iter;

	cout << endl;
        cout << "===PHG4Hit===================================" << endl;
	cout << " PHG4Hit: "; g4hit->identify();

	std::set<SvtxCluster*> clusters = clustereval->all_clusters_from(g4hit);

	for (std::set<SvtxCluster*>::iterator jter = clusters.begin();
	     jter != clusters.end();
	     ++jter) {
	  SvtxCluster *cluster = *jter;
	  cout << "===Created-SvtxCluster================" << endl;      
	  cout << "SvtxCluster: "; cluster->identify();
	}
      }

      PHG4TruthInfoContainer::ConstRange range = truthinfo->GetPrimaryParticleRange();
      for (PHG4TruthInfoContainer::ConstIterator iter = range.first;
	   iter != range.second; 
	   ++iter) {
	
	PHG4Particle *particle = iter->second;

	// track-wise information
	cout << endl;

	cout << "=== Gtrack ===================================================" << endl;
	cout << " PHG4Particle id = " << particle->get_track_id() << endl;
	particle->identify();
	cout << " ptrue = (";
	cout.width(5); cout << particle->get_px();
	cout << ",";
	cout.width(5); cout << particle->get_py();
	cout << ",";
	cout.width(5); cout << particle->get_pz();
	cout << ")" << endl;

	cout << " vtrue = (";
	cout.width(5); cout << truthinfo->GetVtx(particle->get_vtx_id())->get_x();
	cout << ",";
	cout.width(5); cout << truthinfo->GetVtx(particle->get_vtx_id())->get_y();
	cout << ",";
	cout.width(5); cout << truthinfo->GetVtx(particle->get_vtx_id())->get_z();
	cout << ")" << endl;
	  
	cout << " pt = " << sqrt(pow(particle->get_px(),2)+pow(particle->get_py(),2)) << endl;
	cout << " phi = " << atan2(particle->get_py(),particle->get_px()) << endl;
	cout << " eta = " << asinh(particle->get_pz()/sqrt(pow(particle->get_px(),2)+pow(particle->get_py(),2))) << endl;
	  
	cout << " embed flag = " << truthinfo->isEmbeded(particle->get_track_id()) << endl;

	cout << " ---Associated-PHG4Hits-----------------------------------------" << endl;
	std::set<PHG4Hit*> g4hits = trutheval->all_truth_hits(particle);
	for(std::set<PHG4Hit*>::iterator jter = g4hits.begin();
	    jter != g4hits.end();
	    ++jter) {
	  PHG4Hit *g4hit = *jter;

	  float x = 0.5*(g4hit->get_x(0)+g4hit->get_x(1));
	  float y = 0.5*(g4hit->get_y(0)+g4hit->get_y(1));
	  float z = 0.5*(g4hit->get_z(0)+g4hit->get_z(1));
	      
	  cout << " #" << g4hit->get_hit_id() << " xtrue = (";
	  cout.width(5); cout << x;
	  cout << ",";
	  cout.width(5); cout << y;
	  cout << ",";
	  cout.width(5); cout << z;
	  cout << ")";

	  std::set<SvtxCluster*> clusters = clustereval->all_clusters_from(g4hit);
	  for (std::set<SvtxCluster*>::iterator kter = clusters.begin();
	       kter != clusters.end();
	       ++kter) {
	  
	    SvtxCluster *cluster = *kter;

	    float x = cluster->get_x();
	    float y = cluster->get_y();
	    float z = cluster->get_z();
		 
	    cout << " => #" << cluster->get_id(); 
	    cout << " xreco = (";
	    cout.width(5); cout << x;
	    cout << ",";
	    cout.width(5); cout << y;
	    cout << ",";
	    cout.width(5); cout << z;
	    cout << ")";
	  }

	  cout << endl;
	}

	if (trackmap&&clustermap) {

	  std::set<SvtxTrack*> tracks = trackeval->all_tracks_from(particle);
	  for (std::set<SvtxTrack*>::iterator jter = tracks.begin();
	       jter != tracks.end();
	       ++jter) {
	  
	    SvtxTrack *track = *jter;

	    float px = track->get_px();
	    float py = track->get_py();
	    float pz = track->get_pz();

	    cout << "===Created-SvtxTrack==========================================" << endl;
	    cout << " SvtxTrack id = " << track->get_id() << endl;
	    cout << " preco = (";
	    cout.width(5); cout << px;
	    cout << ",";
	    cout.width(5); cout << py;
	    cout << ",";
	    cout.width(5); cout << pz;
	    cout << ")" << endl;
	    cout << " quality = " << track->get_quality() << endl;
	    cout << " nfromtruth = " << trackeval->get_nclusters_contribution(track,particle) << endl;

	    cout << " ---Associated-SvtxClusters-to-PHG4Hits-------------------------" << endl;    

	    for (SvtxTrack::ConstClusterIter iter = track->begin_clusters();
		 iter != track->end_clusters();
		 ++iter) {
	      unsigned int cluster_id = *iter;
	      SvtxCluster* cluster = clustermap->get(cluster_id);
	      		  
	      float x = cluster->get_x();
	      float y = cluster->get_y();
	      float z = cluster->get_z();
			  
	      cout << " #" << cluster->get_id() << " xreco = (";
	      cout.width(5); cout << x;
	      cout << ",";
	      cout.width(5); cout << y;
	      cout << ",";
	      cout.width(5); cout << z;
	      cout << ") =>";

	      PHG4Hit* g4hit = clustereval->max_truth_hit_by_energy(cluster);
	      if ((g4hit) && (g4hit->get_trkid() == particle->get_track_id())) {
			  
		x = 0.5*(g4hit->get_x(0)+g4hit->get_x(1));
		y = 0.5*(g4hit->get_y(0)+g4hit->get_y(1));
		z = 0.5*(g4hit->get_z(0)+g4hit->get_z(1));
			    
		cout << " #" << g4hit->get_hit_id()
		     << " xtrue = (";
		cout.width(5); cout << x;
		cout << ",";
		cout.width(5); cout << y;
		cout << ",";
		cout.width(5); cout << z;
		cout << ") => Gtrack id = " << g4hit->get_trkid();
	      } else {
		cout << " noise hit";
	      }
	    }
  
	    cout << endl;
	  }
	}
      }
    }
      
    cout << endl;

  } // if verbosity

  return;
}

void SvtxEvaluator::fillOutputNtuples(PHCompositeNode *topNode) {

  if (verbosity > 0) cout << "SvtxEvaluator::fillOutputNtuples() entered" << endl;

  SvtxVertexEval*   vertexeval = _svtxevalstack->get_vertex_eval();
  SvtxTrackEval*     trackeval = _svtxevalstack->get_track_eval();
  SvtxClusterEval* clustereval = _svtxevalstack->get_cluster_eval();
  SvtxHitEval*         hiteval = _svtxevalstack->get_hit_eval();
  SvtxTruthEval*     trutheval = _svtxevalstack->get_truth_eval();
  
  //-----------------------
  // fill the Vertex NTuple
  //-----------------------

  if (_ntp_vertex) {
    if (verbosity > 0){
      cout << "Filling ntp_vertex " << endl;
      _timer->restart();
    }
    SvtxVertexMap* vertexmap = findNode::getClass<SvtxVertexMap>(topNode,"SvtxVertexMap");
    PHG4TruthInfoContainer* truthinfo = findNode::getClass<PHG4TruthInfoContainer>(topNode,"G4TruthInfo");
    if (vertexmap && truthinfo) {
      for (SvtxVertexMap::Iter iter = vertexmap->begin();
	   iter != vertexmap->end();
	   ++iter) {
	SvtxVertex* vertex = iter->second;
	PHG4VtxPoint* point = vertexeval->max_truth_point_by_ntracks(vertex);

	float vx         = vertex->get_x();
	float vy         = vertex->get_y();
	float vz         = vertex->get_z();
	float ntracks    = vertex->size_tracks();

	float gvx        = NAN;
	float gvy        = NAN;
	float gvz        = NAN;
	float gvt        = NAN;
	float gntracks   = truthinfo->GetNumPrimaryVertexParticles();
	float nfromtruth = NAN;
	
	if (point) {
	  gvx        = point->get_x();
	  gvy        = point->get_y();
	  gvz        = point->get_z();
	  gvt        = point->get_t();
	  gntracks   = truthinfo->GetNumPrimaryVertexParticles();
	  nfromtruth = vertexeval->get_ntracks_contribution(vertex,point);
	}
	  
	float vertex_data[12] = {(float) _ievent,
				 vx,
				 vy,
				 vz,
				 ntracks,
				 gvx,
				 gvy,
				 gvz,
				 gvt,
				 gntracks,
				 nfromtruth
	};

	/*
	cout << "vertex: " 
	     << " ievent " << vertex_data[0]
	     << " vx " << vertex_data[1]
	     << " vy " << vertex_data[2]
	     << " vz " << vertex_data[3]
	     << endl;
	*/

	_ntp_vertex->Fill(vertex_data);      
      }
    }
    if(verbosity >= 1){
      _timer->stop();
      cout << "vertex time:                "<<_timer->get_accumulated_time()/1000. << " sec" <<endl;
    }
  }
  
  //-----------------------
  // fill the gpoint NTuple
  //-----------------------

  if (_ntp_gpoint)
  {
    if (verbosity > 0)
    {
      cout << "Filling ntp_gpoint " << endl;
      _timer->restart();
    }
    PHG4TruthInfoContainer* truthinfo = findNode::getClass<PHG4TruthInfoContainer>(topNode, "G4TruthInfo");

    if (truthinfo)
    {
      auto vrange = truthinfo->GetPrimaryVtxRange();
      const auto prange = truthinfo->GetPrimaryParticleRange();

      map<int,unsigned int> vertex_particle_count;
      for (auto iter = prange.first; iter != prange.second; ++iter) // process all primary paricle
      {
        ++vertex_particle_count[iter->second->get_vtx_id()];
      }

      for (auto iter = vrange.first; iter != vrange.second; ++iter) // process all primary vertexes
      {
        const int point_id = iter->first;
        PHG4VtxPoint* point = iter->second;

        //      PHG4VtxPoint* point =  truthinfo->GetPrimaryVtx(truthinfo->GetPrimaryVertexIndex());

        if (point)
        {
          SvtxVertex* vertex = vertexeval->best_vertex_from(point);

          float gvx = point->get_x();
          float gvy = point->get_y();
          float gvz = point->get_z();
          float gvt = point->get_t();
          float gntracks = vertex_particle_count[point_id];

          float gembed = truthinfo->isEmbededVtx(point_id);
          float vx = NAN;
          float vy = NAN;
          float vz = NAN;
          float ntracks = NAN;
          float nfromtruth = NAN;

          if (vertex)
          {
            vx = vertex->get_x();
            vy = vertex->get_y();
            vz = vertex->get_z();
            ntracks = vertex->size_tracks();
            nfromtruth = vertexeval->get_ntracks_contribution(vertex, point);
          }

          float gpoint_data[] = {(float) _ievent,
                                   gvx,
                                   gvy,
                                   gvz,
                                   gvt,
                                   gntracks,
                                   gembed,
                                   vx,
                                   vy,
                                   vz,
                                   ntracks,
                                   nfromtruth};

          _ntp_gpoint->Fill(gpoint_data);
        }
      }
    }
    if (verbosity >= 1)
    {
      _timer->stop();
      cout << "gpoint time:                " << _timer->get_accumulated_time() / 1000. << " sec" << endl;
    }
  }
  
  //---------------------
  // fill the G4hit NTuple
  //---------------------

  if (_ntp_g4hit) {
    if (verbosity > 0) {cout << "Filling ntp_g4hit " << endl;_timer->restart();}
    std::set<PHG4Hit*> g4hits = trutheval->all_truth_hits();
    for (std::set<PHG4Hit*>::iterator iter = g4hits.begin();
	 iter != g4hits.end();
	 ++iter) {
            
      PHG4Hit *g4hit = *iter;
      PHG4Particle *g4particle = trutheval->get_particle(g4hit);
      
      float g4hitID   = g4hit->get_hit_id();
      float gx        = g4hit->get_avg_x();
      float gy        = g4hit->get_avg_y();
      float gz        = g4hit->get_avg_z();
      float gt        = g4hit->get_avg_t();
      float gedep     = g4hit->get_edep();
      float glayer    = g4hit->get_layer();
  
      float gtrackID  = g4hit->get_trkid();

      float gflavor   = NAN;
      float gpx       = NAN;
      float gpy       = NAN;
      float gpz       = NAN;
      TVector3 vec(g4hit->get_avg_x(),g4hit->get_avg_y(),g4hit->get_avg_z());
      float gphi      = vec.Phi();
      float gvx       = NAN;
      float gvy       = NAN;
      float gvz       = NAN;

      float gembed    = NAN;
      float gprimary  = NAN;

      float gfpx      = 0.;
      float gfpy      = 0.;
      float gfpz      = 0.;
      float gfx       = 0.;
      float gfy       = 0.;
      float gfz       = 0.;

      if (g4particle) {

	if (_scan_for_embedded) {
	  if (trutheval->get_embed(g4particle) <= 0) continue;
	}
	
	gflavor   = g4particle->get_pid();
	gpx       = g4particle->get_px();
	gpy       = g4particle->get_py();
	gpz       = g4particle->get_pz();

	PHG4VtxPoint* vtx = trutheval->get_vertex(g4particle);	

	if (vtx) {
	  gvx       = vtx->get_x();
	  gvy       = vtx->get_y();
	  gvz       = vtx->get_z();
	}
	PHG4Hit* outerhit = nullptr;
	if(_do_eval_light == false)
	  outerhit = trutheval->get_outermost_truth_hit(g4particle);	

	if (outerhit) {
	  gfpx      = outerhit->get_px(1);
	  gfpy      = outerhit->get_py(1);
	  gfpz      = outerhit->get_pz(1);
	  gfx       = outerhit->get_x(1);
	  gfy       = outerhit->get_y(1);
	  gfz       = outerhit->get_z(1);
	}
	
	gembed    = trutheval->get_embed(g4particle);
	gprimary  = trutheval->is_primary(g4particle);
      } //       if (g4particle)
      
      std::set<SvtxCluster*> clusters = clustereval->all_clusters_from(g4hit);  
      float nclusters = clusters.size();

      // best cluster reco'd
      //      SvtxCluster* cluster = nullptr;//clustereval->best_cluster_from(g4hit);
      SvtxCluster* cluster = clustereval->best_cluster_from(g4hit);

      float clusID     = NAN;
      float x          = NAN;
      float y          = NAN;
      float z          = NAN;
      float e          = NAN;
      float adc        = NAN;
      float layer      = NAN;
      float size       = NAN;
      float phisize    = NAN;
      float zsize      = NAN;
      float efromtruth = NAN;

      if (cluster) {
	clusID     = cluster->get_id();
	x          = cluster->get_x();
	y          = cluster->get_y();
	z          = cluster->get_z();
	e          = cluster->get_e();
	adc        = cluster->get_adc();
	layer      = cluster->get_layer();
	size       = cluster->size_hits();
	phisize    = cluster->get_phi_size();
	zsize      = cluster->get_z_size();
	if (g4particle) {
	  efromtruth = clustereval->get_energy_contribution(cluster,g4particle);
	}
      }

      float g4hit_data[37] = {(float) _ievent,
			      g4hitID,
			      gx,
			      gy,
			      gz,
			      gt,
			      gedep,
			      gphi,
			      glayer,
			      gtrackID,
			      gflavor,
			      gpx,
			      gpy,
			      gpz,
			      gvx,
			      gvy,
			      gvz,
			      gfpx,
			      gfpy,
			      gfpz,
			      gfx,
			      gfy,
			      gfz,
			      gembed,
			      gprimary,
			      nclusters,
			      clusID,  
			      x,      
			      y,      
			      z,      
			      e,      
			      adc,    
			      layer,  
			      size,   
			      phisize,
			      zsize,  
			      efromtruth
      };

      _ntp_g4hit->Fill(g4hit_data);
    }
    if(verbosity >= 1){
      _timer->stop();
      cout << "g4hit time:                "<<_timer->get_accumulated_time()/1000. << " sec" <<endl;
    }
  }
  
  //--------------------
  // fill the Hit NTuple
  //--------------------

  if (_ntp_hit) {
    if (verbosity > 0){ cout << "Filling ntp_hit " << endl;_timer->restart();}
    // need things off of the DST...
    SvtxHitMap* hitmap = findNode::getClass<SvtxHitMap>(topNode,"SvtxHitMap");
    PHG4CylinderCellGeomContainer* geom_container =
      findNode::getClass<PHG4CylinderCellGeomContainer>(topNode,"CYLINDERCELLGEOM_SVTX");
    if (!geom_container) {
      std::cout << PHWHERE << "ERROR: Can't find node CYLINDERCELLGEOM_SVTX" << std::endl;
      return;
    }
    
    if (hitmap) {

      for (SvtxHitMap::Iter iter = hitmap->begin();
	   iter != hitmap->end();
	   ++iter) {

	SvtxHit* hit             = iter->second;
	PHG4Hit* g4hit           = hiteval->max_truth_hit_by_energy(hit);
	PHG4Cell* g4cell = hiteval->get_cell(hit);
	PHG4Particle* g4particle = trutheval->get_particle(g4hit);

	float event  = _ievent;
	float hitID  = hit->get_id();
	float e      = hit->get_e();
	float adc    = hit->get_adc();
	float layer  = hit->get_layer();
	float cellID = hit->get_cellid();
	float ecell  = g4cell->get_edep();
	
	int phibin   = NAN;
 	int zbin     = NAN;
 	float phi    = NAN;
 	float z      = NAN;
	PHG4CylinderCellGeom *GeoLayer = geom_container->GetLayerCellGeom(layer);

	if(layer>=_nlayers_maps+_nlayers_intt){
	  //"cellID:ecell:phibin:zbin:phi:z"
	  phibin = PHG4CellDefs::SizeBinning::get_phibin(g4cell->get_cellid());//cell->get_binphi();
	  zbin = PHG4CellDefs::SizeBinning::get_zbin(g4cell->get_cellid());//cell->get_binz();
	  phi = GeoLayer->get_phicenter( phibin );
	  z = GeoLayer->get_zcenter( zbin );
	}

	float g4hitID  = NAN;
	float gedep    = NAN;
	float gx       = NAN;
	float gy       = NAN;
	float gz       = NAN;
	float gt       = NAN;
	float gtrackID = NAN;
	float gflavor  = NAN;
	float gpx      = NAN;
	float gpy      = NAN;
	float gpz      = NAN;
	float gvx      = NAN;
	float gvy      = NAN;
	float gvz      = NAN;
	float gfpx     = NAN;
	float gfpy     = NAN;
	float gfpz     = NAN;
	float gfx      = NAN;
	float gfy      = NAN;
	float gfz      = NAN;
	float gembed   = NAN;
	float gprimary = NAN;
      
	float efromtruth = NAN;
      
	if (g4hit) {
	  g4hitID  = g4hit->get_hit_id();
	  gedep    = g4hit->get_edep();
	  gx       = g4hit->get_avg_x();
	  gy       = g4hit->get_avg_y();
	  gz       = g4hit->get_avg_z();
	  gt       = g4hit->get_avg_t();

	  if (g4particle) {

	    if (_scan_for_embedded) {
	      if (trutheval->get_embed(g4particle) <= 0) continue;
	    }
	    
	    gtrackID = g4particle->get_track_id();
	    gflavor  = g4particle->get_pid();
	    gpx      = g4particle->get_px();
	    gpy      = g4particle->get_py();
	    gpz      = g4particle->get_pz();

	    PHG4VtxPoint* vtx = trutheval->get_vertex(g4particle);

	    if (vtx) {
	      gvx      = vtx->get_x();
	      gvy      = vtx->get_y();
	      gvz      = vtx->get_z();
	    }

	    PHG4Hit* outerhit = NULL;
	    if(_do_eval_light == false)
 	      outerhit = trutheval->get_outermost_truth_hit(g4particle);
	    if (outerhit) {
	      gfpx     = outerhit->get_px(1);
	      gfpy     = outerhit->get_py(1);
	      gfpz     = outerhit->get_pz(1);
	      gfx      = outerhit->get_x(1);
	      gfy      = outerhit->get_y(1);
	      gfz      = outerhit->get_z(1);
	    }
	    gembed   = trutheval->get_embed(g4particle);
	    gprimary = trutheval->is_primary(g4particle);
	  } //   if (g4particle){
	}      

	if (g4particle) {
	  efromtruth = hiteval->get_energy_contribution(hit,g4particle);
	}

	float hit_data[35] = {
	  event,
	  hitID,
	  e,
	  adc,
	  layer,
	  cellID,
	  ecell,
	  (float) phibin,
	  (float) zbin,
	  phi,
	  z,
	  g4hitID,
	  gedep,
	  gx,
	  gy,
	  gz,
	  gt,
	  gtrackID,
	  gflavor,
	  gpx,
	  gpy,
	  gpz,
	  gvx,
	  gvy,
	  gvz,
	  gfpx,
	  gfpy,
	  gfpz,
	  gfx,
	  gfy,
	  gfz,
	  gembed,
	  gprimary,
	  efromtruth
	};
	  
	_ntp_hit->Fill(hit_data);     
      }
    }
    if(verbosity >= 1){
      _timer->stop();
      cout << "hit time:                "<<_timer->get_accumulated_time()/1000. << " sec" <<endl;
    }
  }
  
  //------------------------
  // fill the Cluster NTuple
  //------------------------

  if (verbosity > 0){ cout << "check for ntp_cluster" << endl;_timer->restart();}

  if (_ntp_cluster && !_scan_for_embedded) {
    if (verbosity > 0) cout << "Filling ntp_cluster (all of them) " << endl;
    // need things off of the DST...
    SvtxClusterMap* clustermap = findNode::getClass<SvtxClusterMap>(topNode,"SvtxClusterMap");
    if (clustermap) {

      for (SvtxClusterMap::Iter iter = clustermap->begin();
	   iter != clustermap->end();
	   ++iter) {
    
	SvtxCluster* cluster     = iter->second;   
	SvtxTrack* track         = trackeval->best_track_from(cluster);
       	PHG4Hit *g4hit           = clustereval->max_truth_hit_by_energy(cluster); 
	PHG4Particle *g4particle = trutheval->get_particle(g4hit);
    
	float hitID    = cluster->get_id();
	float x        = cluster->get_x();
	float y        = cluster->get_y();
	float z        = cluster->get_z();
	TVector3 pos(x,y,z);
	float r = pos.Perp();
	float phi = pos.Phi();
	float eta = pos.Eta();

	float ex       = sqrt(cluster->get_error(0,0));
	float ey       = sqrt(cluster->get_error(1,1));
	float ez       = cluster->get_z_error();

	float ephi     = cluster->get_rphi_error();
	
	float e        = cluster->get_e();
	float adc      = cluster->get_adc();
	float layer    = cluster->get_layer();
	float size     = cluster->size_hits();
	float phisize  = cluster->get_phi_size();
	float zsize    = cluster->get_z_size();

	float trackID  = NAN;
	if (track) trackID = track->get_id();

	float g4hitID  = NAN;
	float gx       = NAN;
	float gy       = NAN;
	float gz       = NAN;
	float gr       = NAN;
	float gphi     = NAN;
	float geta     = NAN;
	float gt       = NAN;
	float gtrackID = NAN;
	float gflavor  = NAN;
	float gpx      = NAN;
	float gpy      = NAN;
	float gpz      = NAN;
	float gvx      = NAN;
	float gvy      = NAN;
	float gvz      = NAN;
	float gfpx     = NAN;
	float gfpy     = NAN;
	float gfpz     = NAN;
	float gfx      = NAN;
	float gfy      = NAN;
	float gfz      = NAN;
	float gembed   = NAN;
	float gprimary = NAN;
    
	float efromtruth = NAN;
      
	if (g4hit) {
	  g4hitID  = g4hit->get_hit_id();
	  gx       = g4hit->get_avg_x();
	  gy       = g4hit->get_avg_y();
	  gz       = g4hit->get_avg_z();
	  TVector3 gpos(gx,gy,gz);
	  gr = gpos.Perp();
	  gphi = gpos.Phi();
	  geta = gpos.Eta();
	  gt       = g4hit->get_avg_t();

	  if (g4particle) {

	    gtrackID = g4particle->get_track_id();
	    gflavor  = g4particle->get_pid();
	    gpx      = g4particle->get_px();
	    gpy      = g4particle->get_py();
	    gpz      = g4particle->get_pz();
	    
	    PHG4VtxPoint* vtx = trutheval->get_vertex(g4particle);
	    if (vtx) {
	      gvx      = vtx->get_x();
	      gvy      = vtx->get_y();
	      gvz      = vtx->get_z();
	    }
	    
	    PHG4Hit* outerhit = nullptr;
	    if(_do_eval_light == false)
	      outerhit = trutheval->get_outermost_truth_hit(g4particle);	
	    if (outerhit) {
	      gfpx     = outerhit->get_px(1);
	      gfpy     = outerhit->get_py(1);
	      gfpz     = outerhit->get_pz(1);
	      gfx      = outerhit->get_x(1);
	      gfy      = outerhit->get_y(1);
	      gfz      = outerhit->get_z(1);
	    }
	    
	    gembed   = trutheval->get_embed(g4particle);
	    gprimary = trutheval->is_primary(g4particle);
	    
	  }      //   if (g4particle){
	} //  if (g4hit) {

	if (g4particle){
	  efromtruth = clustereval->get_energy_contribution(cluster,g4particle);
	}

	float nparticles = clustereval->all_truth_particles(cluster).size();

	float cluster_data[45] = {(float) _ievent,
				  hitID,
				  x,
				  y,
				  z,
				  r,
				  phi,
				  eta,
				  ex,
				  ey,
				  ez,
				  ephi,
				  e,
				  adc,
				  layer,
				  size,
				  phisize,
				  zsize,
				  trackID,
				  g4hitID,
				  gx,
				  gy,
				  gz,
				  gr,
				  gphi,
				  geta,
				  gt,
				  gtrackID,
				  gflavor,
				  gpx,
				  gpy,
				  gpz,
				  gvx,
				  gvy,
				  gvz,
				  gfpx,
				  gfpy,
				  gfpz,
				  gfx,
				  gfy,
				  gfz,
				  gembed,
				  gprimary,
				  efromtruth,
				  nparticles
	};

	_ntp_cluster->Fill(cluster_data);
      }		  
    }
    
  } else if (_ntp_cluster && _scan_for_embedded) {

    if (verbosity > 0) cout << "Filling ntp_cluster (embedded only) " << endl;

    // if only scanning embedded signals, loop over all the tracks from
    // embedded particles and report all of their clusters, including those
    // from other sources (noise hits on the embedded track)
    
    // need things off of the DST...
    SvtxTrackMap* trackmap = findNode::getClass<SvtxTrackMap>(topNode,_trackmapname.c_str());
    SvtxClusterMap* clustermap = findNode::getClass<SvtxClusterMap>(topNode,"SvtxClusterMap");
    if (trackmap) {
      
      for (SvtxTrackMap::Iter iter = trackmap->begin();
	   iter != trackmap->end();
	   ++iter) {
	
	SvtxTrack* track = iter->second;
	PHG4Particle* truth = trackeval->max_truth_particle_by_nclusters(track);
	if (truth) {	  
	  if (trutheval->get_embed(truth) <= 0) continue;
	}
	
	for (SvtxTrack::ConstClusterIter iter = track->begin_clusters();
	     iter != track->end_clusters();
	     ++iter) {

	  unsigned int cluster_id = *iter;
	  SvtxCluster* cluster = clustermap->get(cluster_id);

	  PHG4Hit *g4hit           = clustereval->max_truth_hit_by_energy(cluster); 
	  PHG4Particle *g4particle = trutheval->get_particle(g4hit);
    
	  float hitID    = cluster->get_id();
	  float x        = cluster->get_x();
	  float y        = cluster->get_y();
	  float z        = cluster->get_z();

	  float ex       = sqrt(cluster->get_error(0,0));
	  float ey       = sqrt(cluster->get_error(1,1));
	  float ez       = cluster->get_z_error();

	  float ephi     = cluster->get_rphi_error();
	  
	  float e        = cluster->get_e();
	  float adc      = cluster->get_adc();
	  float layer    = cluster->get_layer();
	  float size     = cluster->size_hits();
	  float phisize  = cluster->get_phi_size();
	  float zsize    = cluster->get_z_size();

	  float trackID  = NAN;
	  if (track) trackID = track->get_id();

	  float g4hitID  = NAN;
	  float gx       = NAN;
	  float gy       = NAN;
	  float gz       = NAN;
	  float gt       = NAN;
	  float gtrackID = NAN;
	  float gflavor  = NAN;
	  float gpx      = NAN;
	  float gpy      = NAN;
	  float gpz      = NAN;
	  float gvx      = NAN;
	  float gvy      = NAN;
	  float gvz      = NAN;
	  float gfpx     = NAN;
	  float gfpy     = NAN;
	  float gfpz     = NAN;
	  float gfx      = NAN;
	  float gfy      = NAN;
	  float gfz      = NAN;
	  float gembed   = NAN;
	  float gprimary = NAN;
    
	  float efromtruth = NAN;
      
	  if (g4hit) {
	    g4hitID  = g4hit->get_hit_id();
	    gx       = g4hit->get_avg_x();
	    gy       = g4hit->get_avg_y();
	    gz       = g4hit->get_avg_z();
	    gt       = g4hit->get_avg_t();

	    if (g4particle) {
	    
	      gtrackID = g4particle->get_track_id();
	      gflavor  = g4particle->get_pid();
	      gpx      = g4particle->get_px();
	      gpy      = g4particle->get_py();
	      gpz      = g4particle->get_pz();

	      PHG4VtxPoint* vtx = trutheval->get_vertex(g4particle);
	      if (vtx) {
		gvx      = vtx->get_x();
		gvy      = vtx->get_y();
		gvz      = vtx->get_z();
	      }
	      PHG4Hit* outerhit = nullptr;
	      if(_do_eval_light == false)
		outerhit = trutheval->get_outermost_truth_hit(g4particle);	
	      if (outerhit) {
		gfpx     = outerhit->get_px(1);
		gfpy     = outerhit->get_py(1);
		gfpz     = outerhit->get_pz(1);
		gfx      = outerhit->get_x(1);
		gfy      = outerhit->get_y(1);
		gfz      = outerhit->get_z(1);
	      }
	    
	      gembed   = trutheval->get_embed(g4particle);
	      gprimary = trutheval->is_primary(g4particle);
	    }      //   if (g4particle){
	  } //  if (g4hit) {

	  if (g4particle){
	    efromtruth = clustereval->get_energy_contribution(cluster,g4particle);
	  }

	  float nparticles = clustereval->all_truth_particles(cluster).size();

	  float cluster_data[39] = {(float) _ievent,
				    hitID,
				    x,
				    y,
				    z,
				    ex,
				    ey,
				    ez,
				    ephi,
				    e,
				    adc,
				    layer,
				    size,
				    phisize,
				    zsize,
				    trackID,
				    g4hitID,
				    gx,
				    gy,
				    gz,
				    gt,
				    gtrackID,
				    gflavor,
				    gpx,
				    gpy,
				    gpz,
				    gvx,
				    gvy,
				    gvz,
				    gfpx,
				    gfpy,
				    gfpz,
				    gfx,
				    gfy,
				    gfz,
				    gembed,
				    gprimary,
				    efromtruth,
					nparticles
	  };

	  _ntp_cluster->Fill(cluster_data);
	}		  
      }
    }
  }
  if(verbosity >= 1){
    _timer->stop();
    cout << "cluster time:                "<<_timer->get_accumulated_time()/1000. << " sec" <<endl;
  }
  //------------------------
  // fill the Gtrack NTuple
  //------------------------

  // need things off of the DST...

  //cout << "check for ntp_gtrack" << endl;

  if (_ntp_gtrack) {
    if (verbosity > 0){ cout << "Filling ntp_gtrack " << endl;_timer->restart();}

    PHG4TruthInfoContainer* truthinfo = findNode::getClass<PHG4TruthInfoContainer>(topNode,"G4TruthInfo");   
    SvtxClusterMap* clustermap = findNode::getClass<SvtxClusterMap>(topNode,"SvtxClusterMap");
    if (truthinfo) {

      PHG4TruthInfoContainer::ConstRange range = truthinfo->GetPrimaryParticleRange();
      for (PHG4TruthInfoContainer::ConstIterator iter = range.first;
	   iter != range.second; 
	 ++iter) {
	
	PHG4Particle* g4particle = iter->second;

	if (_scan_for_embedded) {
	  if (trutheval->get_embed(g4particle) <= 0) continue;
	}
	
	float gtrackID = g4particle->get_track_id();
	float gflavor  = g4particle->get_pid();
      
	//std::set<PHG4Hit*> g4hits = trutheval->all_truth_hits(g4particle);
	std::set<SvtxCluster*> g4clusters = clustereval->all_clusters_from(g4particle);
    
	float ng4hits = g4clusters.size();
	unsigned int ngmaps  = 0;
	unsigned int ngintt  = 0;
	unsigned int ngtpc   = 0;
	unsigned int nglmaps = 0;
	unsigned int nglintt = 0;
	unsigned int ngltpc  = 0;

	int lmaps[_nlayers_maps+1]; 
	if(_nlayers_maps>0) for(unsigned int i = 0;i<_nlayers_maps;i++) lmaps[i] = 0;

	int lintt[_nlayers_intt+1];
	if(_nlayers_intt>0) for(unsigned int i = 0;i<_nlayers_intt;i++) lintt[i] = 0; 

	int ltpc[_nlayers_tpc+1];
	if(_nlayers_tpc>0) for(unsigned int i = 0;i<_nlayers_tpc;i++) ltpc[i] = 0; 

	for(const SvtxCluster* g4cluster : g4clusters){
	  unsigned int layer = g4cluster->get_layer();
	  //cout<<__LINE__<<": " << _ievent <<": " <<gtrackID << ": " << layer <<": " <<g4cluster->get_id() <<endl;
	  if(_nlayers_maps>0&&layer<_nlayers_maps) {
		  lmaps[layer] = 1;
		  ngmaps++;
	  }

	  if(_nlayers_intt>0&&layer>=_nlayers_maps&&layer<_nlayers_maps+_nlayers_intt){ 
	    lintt[layer-_nlayers_maps] = 1;
	    ngintt++;
	  }

	  if(_nlayers_tpc>0&&layer>=_nlayers_maps+_nlayers_intt && layer<_nlayers_maps+_nlayers_intt+_nlayers_tpc){ 
	    ltpc[layer-(_nlayers_maps+_nlayers_intt)] = 1;
	    ngtpc++;
	  }
	}
	if(_nlayers_maps>0) for(unsigned int i = 0;i<_nlayers_maps;i++) nglmaps+=lmaps[i];
	if(_nlayers_intt>0) for(unsigned int i = 0;i<_nlayers_intt;i++) nglintt+=lintt[i];
	if(_nlayers_tpc>0)  for(unsigned int i = 0;i<_nlayers_tpc;i++)  ngltpc+=ltpc[i];

	float gpx      = g4particle->get_px();
	float gpy      = g4particle->get_py();
	float gpz      = g4particle->get_pz();
	float gpt      = NAN;
	float geta     = NAN;
	float gphi     = NAN;
	if(gpx!=0&&gpy!=0){
	  TVector3 gv(gpx,gpy,gpz);
	  gpt  = gv.Pt();
	  geta = gv.Eta();
	  gphi = gv.Phi();
	}
	PHG4VtxPoint* vtx = trutheval->get_vertex(g4particle);	
	float gvx      = vtx->get_x();
	float gvy      = vtx->get_y();
	float gvz      = vtx->get_z();
	float gvt      = vtx->get_t();

	float gfpx      = 0.;
	float gfpy      = 0.;
	float gfpz      = 0.;
	float gfx       = 0.;
	float gfy       = 0.;
	float gfz       = 0.;
    
	PHG4Hit* outerhit = nullptr;
	if(_do_eval_light == false)
	  outerhit = trutheval->get_outermost_truth_hit(g4particle);	

	if (outerhit) {
	  gfpx      = outerhit->get_px(1);
	  gfpy      = outerhit->get_py(1);
	  gfpz      = outerhit->get_pz(1);
	  gfx       = outerhit->get_x(1);
	  gfy       = outerhit->get_y(1);
	  gfz       = outerhit->get_z(1);
	}
      
	float gembed   = trutheval->get_embed(g4particle);
	float gprimary = trutheval->is_primary(g4particle);

	float trackID       = NAN;
	float charge        = NAN;
	float quality       = NAN;
	float chisq         = NAN;
	float ndf           = NAN;
	float nhits         = NAN;
	float nmaps         =  0;
	float nintt         =  0;
	float ntpc          =  0;
	float nlintt        =  0;
	float nlmaps        =  0;
	float nltpc         =  0;
	unsigned int layers = 0x0;
	float dca2d         = NAN;
	float dca2dsigma    = NAN;
	float dca3dxy		 = NAN;
	float dca3dxysigma	 = NAN;
	float dca3dz		 = NAN;
	float dca3dzsigma	 = NAN;
	float px            = NAN;
	float py            = NAN;
	float pz            = NAN;
	float pt            = NAN;
	float eta           = NAN;
	float phi           = NAN;
	float pcax          = NAN;
	float pcay          = NAN;
	float pcaz          = NAN;

	float nfromtruth    = NAN;
	float nwrong        = NAN;
	float ntrumaps      = NAN;
	float ntruintt      = NAN;
	float ntrutpc       = NAN;
	float layersfromtruth = NAN;

	if(_do_track_match){
	  SvtxTrack* track = trackeval->best_track_from(g4particle);
	  
	  if (track) {
	    trackID   = track->get_id();     
	    charge    = track->get_charge();
	    quality   = track->get_quality();
	    chisq     = track->get_chisq();
	    ndf       = track->get_ndf();
	    nhits     = track->size_clusters();
	    int maps[_nlayers_maps];
	    int intt[_nlayers_intt];
	    int tpc[_nlayers_tpc];
	    
	    if(_nlayers_maps>0){
	      for(unsigned int i = 0;i<_nlayers_maps;i++) maps[i] = 0;
	    }
	    if(_nlayers_intt>0){
	      for(unsigned int i = 0;i<_nlayers_intt;i++) intt[i] = 0; 
	    }
	    if(_nlayers_tpc>0){
	      for(unsigned int i = 0;i<_nlayers_tpc;i++) tpc[i] = 0; 
	    }
	    
	    for (SvtxTrack::ConstClusterIter iter = track->begin_clusters();
		 iter != track->end_clusters();
		 ++iter) {
	      unsigned int cluster_id = *iter;
	      SvtxCluster* cluster = clustermap->get(cluster_id);
	      unsigned int layer = cluster->get_layer();
	      if(_nlayers_maps>0&&layer<_nlayers_maps){ maps[layer] = 1; nmaps++;}
	      if(_nlayers_intt>0&&layer>=_nlayers_maps&&layer<_nlayers_maps+_nlayers_intt){ intt[layer-_nlayers_maps] = 1;nintt++;}
	      if(_nlayers_tpc>0&&
		 layer>=(_nlayers_maps+_nlayers_intt)&&
		 layer<(_nlayers_maps+_nlayers_intt+_nlayers_tpc)){ 
		tpc[layer-(_nlayers_maps+_nlayers_intt)] = 1;ntpc++;
	      }
	    }
	    if(_nlayers_maps>0) for(unsigned int i = 0;i<_nlayers_maps;i++) nlmaps+=maps[i];
	    if(_nlayers_intt>0) for(unsigned int i = 0;i<_nlayers_intt;i++) nlintt+=intt[i];
	    if(_nlayers_tpc>0 ) for(unsigned int i = 0;i<_nlayers_tpc;i++)  nltpc+=tpc[i];
	    
	    layers = nlmaps+nlintt+nltpc;
	    
	    dca2d     = track->get_dca2d();
	    dca2dsigma = track->get_dca2d_error();
	    dca3dxy     = track->get_dca3d_xy();
	    dca3dxysigma = track->get_dca3d_xy_error();
	    dca3dz     = track->get_dca3d_z();
	    dca3dzsigma = track->get_dca3d_z_error();
	    px        = track->get_px();
	    py        = track->get_py();
	    pz        = track->get_pz();
	    TVector3 v(px,py,pz);
	    pt = v.Pt();
	    eta = v.Eta();
	    phi = v.Phi();
	    pcax      = track->get_x();
	    pcay      = track->get_y();
	    pcaz      = track->get_z();
	    
	    nfromtruth = trackeval->get_nclusters_contribution(track,g4particle);
	    nwrong     = trackeval->get_nwrongclusters_contribution(track,g4particle);
	    
	    if(_nlayers_maps==0){
	      ntrumaps   = 0;
	    }else{
	      ntrumaps   = trackeval->get_layer_range_contribution(track,g4particle,0,_nlayers_maps);
	    }
	    if(_nlayers_intt==0){
	      ntruintt   = 0;
	    }else{
	      ntruintt   = trackeval->get_layer_range_contribution(track,g4particle,_nlayers_maps,_nlayers_maps+_nlayers_intt);
	    }
	    ntrutpc    = trackeval->get_layer_range_contribution(track,g4particle,_nlayers_maps+_nlayers_intt,_nlayers_maps+_nlayers_intt+_nlayers_tpc);
	    
	    layersfromtruth = trackeval->get_nclusters_contribution_by_layer(track,g4particle);
	  }
	}
	float gtrack_data[62] = {(float) _ievent,
				 gtrackID,
				 gflavor,
				 ng4hits,
				 (float)ngmaps,
				 (float)ngintt,
				 (float)ngtpc,
				 (float)nglmaps,
				 (float)nglintt,
				 (float)ngltpc,
				 gpx,
				 gpy,
				 gpz,
				 gpt,
				 geta,
				 gphi,
				 gvx,
				 gvy,
				 gvz,
				 gvt,
				 gfpx,
				 gfpy,
				 gfpz,
				 gfx,
				 gfy,
				 gfz,
				 gembed,
				 gprimary,
				 trackID,
				 px,         
				 py,         
				 pz,  
				 pt,         
				 eta,         
				 phi,  
				 charge,     
				 quality,    
				 chisq,      
				 ndf,        
				 nhits,      
				 (float) layers,
				 nmaps,
				 nintt,
				 ntpc,
				 nlmaps,
				 nlintt,
				 nltpc,
				 dca2d,      
				 dca2dsigma,
				 dca3dxy,
				 dca3dxysigma,
				 dca3dz,
				 dca3dzsigma,
				 pcax,       
				 pcay,       
				 pcaz,
				 nfromtruth,
				 nwrong,
				 ntrumaps,
				 ntruintt,
				 ntrutpc,
				 layersfromtruth
	};

	/*
	cout << " ievent " << _ievent
	     << " gtrackID " << gtrackID
	     << " gflavor " << gflavor
	     << " ng4hits " << ng4hits
	     << endl;
	*/

	_ntp_gtrack->Fill(gtrack_data);

      }	     
    }
    if(verbosity >= 1){
      _timer->stop();
      cout << "gtrack time:                "<<_timer->get_accumulated_time()/1000. << " sec" <<endl;
    }
  }
  
  //------------------------
  // fill the Track NTuple
  //------------------------



  if (_ntp_track) {
    if (verbosity > 0){ cout << "Filling ntp_track " << endl;_timer->restart();}

    // need things off of the DST...
    SvtxTrackMap* trackmap = findNode::getClass<SvtxTrackMap>(topNode,_trackmapname.c_str());
    SvtxClusterMap* clustermap = findNode::getClass<SvtxClusterMap>(topNode,"SvtxClusterMap");
    if (trackmap) {

      for (SvtxTrackMap::Iter iter = trackmap->begin();
	   iter != trackmap->end();
	   ++iter) {
    
	SvtxTrack* track = iter->second;

	float trackID   = track->get_id();     
	float charge    = track->get_charge();
	float quality   = track->get_quality();
	float chisq     = track->get_chisq();
	float ndf       = track->get_ndf();
	float nhits     = track->size_clusters();
	unsigned int layers = 0x0;
	int maps[_nlayers_maps];
	int intt[_nlayers_intt];
	int tpc[_nlayers_tpc];
	if(_nlayers_maps>0){
	  for(unsigned int i = 0;i<_nlayers_maps;i++) maps[i] = 0;
	}
	if(_nlayers_intt>0){
	  for(unsigned int i = 0;i<_nlayers_intt;i++) intt[i] = 0; 
	}
	if(_nlayers_tpc>0){
	  for(unsigned int i = 0;i<_nlayers_tpc;i++) tpc[i] = 0; 
	}

	float nmaps  = 0;
	float nintt  = 0;
	float ntpc   = 0;
	float nlmaps = 0;
	float nlintt = 0;
	float nltpc  = 0;


	for (SvtxTrack::ConstClusterIter iter = track->begin_clusters();
	     iter != track->end_clusters();
	     ++iter) {
	  unsigned int cluster_id = *iter;
	  SvtxCluster* cluster = clustermap->get(cluster_id);
	  unsigned int layer = cluster->get_layer();

	  if(_nlayers_maps>0&&layer<_nlayers_maps){ maps[layer] = 1; nmaps++;}
	  if(_nlayers_intt>0&&layer>=_nlayers_maps&&layer<_nlayers_maps+_nlayers_intt){ intt[layer-_nlayers_maps] = 1;nintt++;}
	  if(_nlayers_tpc>0&&layer>=(_nlayers_maps+_nlayers_intt)&&layer<(_nlayers_maps+_nlayers_intt+_nlayers_tpc)){
	    tpc[layer - (_nlayers_maps+_nlayers_intt)] = 1;
	    ntpc++;
	  }
	}
	if(_nlayers_maps>0) for(unsigned int i = 0;i<_nlayers_maps;i++) nlmaps+=maps[i];
	if(_nlayers_intt>0) for(unsigned int i = 0;i<_nlayers_intt;i++) nlintt+=intt[i];
	if(_nlayers_tpc>0)  for(unsigned int i = 0;i<_nlayers_tpc;i++)  nltpc+=tpc[i];
	layers = nlmaps+nlintt+nltpc;
	float dca2d     = track->get_dca2d();
	float dca2dsigma = track->get_dca2d_error();
    float dca3dxy     = track->get_dca3d_xy();
    float dca3dxysigma = track->get_dca3d_xy_error();
    float dca3dz     = track->get_dca3d_z();
    float dca3dzsigma = track->get_dca3d_z_error();
	float px        = track->get_px();
	float py        = track->get_py();
	float pz        = track->get_pz();
	TVector3 v(px,py,pz);
	float pt        = v.Pt();
	float eta       = v.Eta();
	float phi       = v.Phi();
	float pcax      = track->get_x();
	float pcay      = track->get_y();
	float pcaz      = track->get_z();

	float presdphi = track->get_cal_dphi(SvtxTrack::PRES);
	float presdeta = track->get_cal_deta(SvtxTrack::PRES);
	float prese3x3 = track->get_cal_energy_3x3(SvtxTrack::PRES);
	float prese    = track->get_cal_cluster_e(SvtxTrack::PRES);

	float cemcdphi = track->get_cal_dphi(SvtxTrack::CEMC);
	float cemcdeta = track->get_cal_deta(SvtxTrack::CEMC);
	float cemce3x3 = track->get_cal_energy_3x3(SvtxTrack::CEMC);
	float cemce    = track->get_cal_cluster_e(SvtxTrack::CEMC);

	float hcalindphi = track->get_cal_dphi(SvtxTrack::HCALIN);
	float hcalindeta = track->get_cal_deta(SvtxTrack::HCALIN);
	float hcaline3x3 = track->get_cal_energy_3x3(SvtxTrack::HCALIN);
	float hcaline    = track->get_cal_cluster_e(SvtxTrack::HCALIN);

	float hcaloutdphi = track->get_cal_dphi(SvtxTrack::HCALOUT);
	float hcaloutdeta = track->get_cal_deta(SvtxTrack::HCALOUT);
	float hcaloute3x3 = track->get_cal_energy_3x3(SvtxTrack::HCALOUT);
	float hcaloute    = track->get_cal_cluster_e(SvtxTrack::HCALOUT);

	float gtrackID = NAN;
	float gflavor  = NAN;     
	float ng4hits  = NAN;
	unsigned int ngmaps   = 0;
	unsigned int ngintt   = 0;
	unsigned int ngtpc    = 0;
	unsigned int nglmaps  = 0;
	unsigned int nglintt  = 0;
	unsigned int ngltpc   = 0;
	float gpx      = NAN;
	float gpy      = NAN;
	float gpt      = NAN;
	float geta     = NAN;
	float gphi     = NAN;
	float gpz      = NAN;
	float gvx      = NAN;
	float gvy      = NAN;
	float gvz      = NAN;
	float gvt      = NAN;
	float gfpx     = NAN;
	float gfpy     = NAN;
	float gfpz     = NAN;
	float gfx      = NAN;
	float gfy      = NAN;
	float gfz      = NAN;
	float gembed   = NAN;
	float gprimary = NAN;

	float nfromtruth = NAN;
	float nwrong     = NAN;
	float ntrumaps   = NAN;
	float ntruintt   = NAN;
	float ntrutpc    = NAN;
	float layersfromtruth = NAN;
      
	if(_do_track_match){
	  PHG4Particle* g4particle = trackeval->max_truth_particle_by_nclusters(track);	
	  
	  if (g4particle) {
	    
	    if (_scan_for_embedded) {
	      if (trutheval->get_embed(g4particle) <= 0) continue;
	    }
	    
	    gtrackID = g4particle->get_track_id();
	    gflavor  = g4particle->get_pid();
	    
	    std::set<SvtxCluster*> g4clusters = clustereval->all_clusters_from(g4particle);
	    ng4hits = g4clusters.size();
	    gpx      = g4particle->get_px();
	    gpy      = g4particle->get_py();
	    gpz      = g4particle->get_pz();
	    
	    int lmaps[_nlayers_maps+1]; 
	    if(_nlayers_maps>0) for(unsigned int i = 0;i<_nlayers_maps;i++) lmaps[i] = 0;
	    
	    int lintt[_nlayers_intt+1];
	    if(_nlayers_intt>0) for(unsigned int i = 0;i<_nlayers_intt;i++) lintt[i] = 0; 
	    
	    int ltpc[_nlayers_tpc+1];
	    if(_nlayers_tpc>0) for(unsigned int i = 0;i<_nlayers_tpc;i++) ltpc[i] = 0; 
	    
	    for(const SvtxCluster* g4cluster : g4clusters){
	  	  unsigned int layer = g4cluster->get_layer();
	  	  if(_nlayers_maps>0&&layer<_nlayers_maps) {
	  		  lmaps[layer] = 1;
	  		  ngmaps++;
	  	  }

	  	  if(_nlayers_intt>0&&layer>=_nlayers_maps&&layer<_nlayers_maps+_nlayers_intt){
	  	    lintt[layer-_nlayers_maps] = 1;
	  	    ngintt++;
	  	  }

	  	  if(_nlayers_tpc>0&&layer>=_nlayers_maps+_nlayers_intt && layer<_nlayers_maps+_nlayers_intt+_nlayers_tpc){
	  	    ltpc[layer-(_nlayers_maps+_nlayers_intt)] = 1;
	  	    ngtpc++;
	  	  }
	    }
	    if(_nlayers_maps>0) for(unsigned int i = 0;i<_nlayers_maps;i++) nglmaps+=lmaps[i];
	    if(_nlayers_intt>0) for(unsigned int i = 0;i<_nlayers_intt;i++) nglintt+=lintt[i];
	    if(_nlayers_tpc>0)  for(unsigned int i = 0;i<_nlayers_tpc;i++)  ngltpc+=ltpc[i];
	    
	    TVector3 gv(gpx,gpy,gpz);
	    gpt      = gv.Pt();
	    geta     = gv.Eta();
	    gphi     = gv.Phi();
	    PHG4VtxPoint* vtx = trutheval->get_vertex(g4particle);	
	    gvx      = vtx->get_x();
	    gvy      = vtx->get_y();
	    gvz      = vtx->get_z();
	    gvt      = vtx->get_t();

	    PHG4Hit* outerhit = nullptr;
	    if(_do_eval_light == false)
	      outerhit = trutheval->get_outermost_truth_hit(g4particle);	
	    if (outerhit) {
	      gfpx     = outerhit->get_px(1);
	      gfpy     = outerhit->get_py(1);
	      gfpz     = outerhit->get_pz(1);
	      gfx      = outerhit->get_x(1);
	      gfy      = outerhit->get_y(1);
	      gfz      = outerhit->get_z(1);
	    }
	    gembed   = trutheval->get_embed(g4particle);
	    gprimary = trutheval->is_primary(g4particle);
	    
	    nfromtruth = trackeval->get_nclusters_contribution(track,g4particle);
	    nwrong     = trackeval->get_nwrongclusters_contribution(track,g4particle);
	    if(_nlayers_maps==0){
	      ntrumaps   = 0;
	    }else{
	      ntrumaps   = trackeval->get_layer_range_contribution(track,g4particle,0,_nlayers_maps);
	    }
	    if(_nlayers_intt==0){
	      ntruintt   = 0;
	    }else{
	      ntruintt   = trackeval->get_layer_range_contribution(track,g4particle,_nlayers_maps,_nlayers_maps+_nlayers_intt);
	    }
	    ntrutpc    = trackeval->get_layer_range_contribution(track,g4particle,_nlayers_maps+_nlayers_intt,_nlayers_maps+_nlayers_intt+_nlayers_tpc);
	    layersfromtruth = trackeval->get_nclusters_contribution_by_layer(track,g4particle);
	  }
	}
      
	float track_data[78] = {(float) _ievent,
				trackID, 
				px,        
				py,        
				pz,      
				pt,        
				eta,        
				phi, 
     				charge,  
				quality, 
				chisq,   
				ndf,     
				nhits,nmaps,nintt,ntpc,nlmaps,nlintt,nltpc,   
				(float) layers,
				dca2d,     
				dca2dsigma,
				dca3dxy,
				dca3dxysigma,
				dca3dz,
				dca3dzsigma,
				pcax,      
				pcay,      
				pcaz,      
				presdphi,
				presdeta,
				prese3x3,
				prese,   
				cemcdphi,
				cemcdeta,
				cemce3x3,
				cemce,   
				hcalindphi,
				hcalindeta,
				hcaline3x3,
				hcaline,   
				hcaloutdphi,
				hcaloutdeta,
				hcaloute3x3,
				hcaloute,
				gtrackID,
				gflavor,
				ng4hits,
				(float)ngmaps,
				(float)ngintt,
				(float)ngtpc,
				(float)nglmaps,
				(float)nglintt,
				(float)ngltpc,
				gpx,
				gpy,
				gpz,
				gpt,
				geta,
				gphi,
				gvx,
				gvy,
				gvz,
				gvt,
				gfpx,
				gfpy,
				gfpz,
				gfx,
				gfy,
				gfz,
				gembed,
				gprimary,
				nfromtruth,
				nwrong,
				ntrumaps,
				ntruintt,
				ntrutpc,
				layersfromtruth
	};

	/*
	cout << "ievent " << _ievent
	     << " trackID " << trackID
	     << " nhits " << nhits
	     << " px " << px
	     << " py " << py
	     << " pz " << pz
	     << " gembed " << gembed
	     << " gprimary " << gprimary 
	     << endl;
	*/
	_ntp_track->Fill(track_data);
      }
    }
    if(verbosity >= 1){
      _timer->stop();
      cout << "track time:                "<<_timer->get_accumulated_time()/1000. << " sec" <<endl;
    }
  }
  
  return;
}
